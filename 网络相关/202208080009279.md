# 网络相关

### 1.http和https区别

1. http是超文本传输协议，明文传输。https是在http基础上增加了ssl协议，来对数据进行加密处理和身份验证，安全性更高。

2. ssl的连接过程，tcp三次握手后，开始进行ssl连接
   1. 客户端发送 Client Hello,表明自己的 TLS版本，加密套机，第一随机数
   2. 服务端发送 Sever Hello，表明自己的TLS版本，选取加密套机，第二随机数
   3. 服务端发送 Certificate，证书
   4. 服务端发送 Server Key Exchange，公钥
   5. 服务器发送 Server Hello Done，表明协商完成
   6. 客户端发送 Client Key Exchange，公钥加密的预主秘钥。自己根据第一、第二、预主秘钥生成会话秘钥
   7. 服务端用私钥解码得到预主秘钥，结合第一、第二随机数生成会话秘钥，发送 Encryted Handshake Message确认
   8. 对称加密通信
3. http协议的端口是80，而https的端口为443。
4. hhtps在网站搜索排名更高
5. 连接费时，增加耗电、加载时间，缓存不如http高效。证书要钱，绑定ip且统一ip不能绑定多个域名。

### 2.http版本

#### 1）1.0和1.1区别

1. 连接方面：http1.0是短连接。1.1是长连接使多个http请求复用一个tcp连接，提高效率。
2. 数据传输：1.0不支持断点传输，1.1支持
3. 缓存方面：1.0主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，1.1增加了许多方案
4. 虚拟网络：1.0认为一个计算机绑定一个ip，不支持虚拟网络。1.1增加host请求头，支持虚拟网络
5. 增加许多相应状态码，新增许多请求方法

#### 2）1.1和2.0

1. 二进制帧：2.0报文都是二进制，1.1时可以使ASCII码。头信息帧和数据帧。
2. 多路复用：可以同时发送多个请求和相应，不用逐一发送。解决对头堵塞的问题。

3. 数据流：2.0每个请求或相应的数据包称为一个数据流。并且每个数据流有一个独特ID
4. 头信息压缩：客户端和服务器共同维护一个表，每次传输只发送索引就好了
5. 服务器推送：服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取

#### 3）3.0

基于QUIC协议：多路复用、tls、有序交付快速握手，udp协议

### 3.http缓存

#### 1）强缓存

1. 强制缓存就是文件直接从本地缓存中获取，不需要发送请求。
2. Cache-Control响应头中设置过期时间

#### 2）协商缓存

1. 服务端判断客户端的资源，是否和服务端资源一样，如果一致则返回 `304` ，反之返回 `200` 和最新的资源。

2. 响应头中`Last-Modified` 和 `Etag`，后者精确度、优先级都高于前者

### 4.http状态码

1XX：提示信息；2XX：成功；3XX：重定向；4XX客户端错误；5XX：服务器错误

301：永久重定向，网页迁移。302：临时重定向，请求资源分配到新的url。

301、302、303都会将POST请求改成GET自动发送去请求资源

401：要求验证身份。403：无权限、包含敏感信息....不能再进行身份验证。404：无法找到请求的资源。

### 5.请求方式

#### 1）GET与POST

1. GET请求体为空
2. 浏览器一般会缓存GET请求
3. POST数据长度更长、支持更多数据类型

#### 2）POST与PUT

post一般为创建数据、PUT一般为更新数据

#### 3）DELETE、HEAD、options

删除数据、没有相应体数据、嗅探请求、

#### 4）其他

**OPTIONS**、**TRACE**、**CONNECT**

### 6.DNS查询过程

浏览器缓存-->系统缓存-->路由器缓存-->本地DNS服务器。递归查询，一次请求得到答案

根域名服务器-->顶级域名服务器-->二级域名服务器。迭代查询。

### 7.OSI七层模型

![七层模型](https://cdn.jsdelivr.net/gh/redvapour/Drawing-bed/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/202208080009731.jpg)

### 8.三次握手

- 客户端和服务端都处于 CLOSE 状态。服务器主动监听某个端口处于 LISTEN状态
- 客户端，发送 SYN 包表示想建立练级，进入**SYN_SEND**状态

> SYN=1，初始序号seq=x，SYN=1

- 服务端，返回SYN + ACK 包，表示收到请求，并表示可以连接，进入**SYN_REVD** 的状态

> SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y

- 客户端，返回ACK包，表示我收到你的同意消息，进入**ESTABLISHED** 

> ACK=1，确认号ack=y+1，序号seq=x+1

两次握手危害：客户端第一次发送的SYN包延迟到达，会使服务端多开一条连接通道

四次握手安全性提高不大

### 9.四次挥手

* 主动方发送 FIN 包表示要结束连接，进入 **FIN_WAIT1** 状态

> FIN=1，序号seq=u）

* 被动方 ACK包表示收到要断开连接的消息，进入 **CLOSE_WAIT**。主动方收到后进入**FIN_WAIT2** 

> ACK=1，确认号ack=u+1，序号seq=v

* 被动方传输数据完成后，发送FIN包，表示可以断开,进入**LAST_ACK**状态

> FIN=1，ACK=1，确认号ack=u+1,序号seq=w

* 主动方发送 ACK 包表示收到同意断开的消息，进入**TIME_WAIT** 状态。被动法收到后立即进入CLOSED状态，主动方等待2MSL（4分钟）后断开进入**CLOSED**状态

> ACK=1，seq=u+1，ack=w+1

### 10.TCP粘包和拆包

#### 1）发生时机

* 要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。

* 待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。

* 要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。

* 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

#### 2）解决办法

* 发送端给每个数据包**添加包首部**，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。

* 发送端将每个数据包**封装为固定长度**（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。

* 可以在数据包之间**设置边界**，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。

